import copy

import numpy as np
import theano
import theano.tensor as tensor
from theano.tensor.nnet import conv

import pyll

use_pythor3_defaults = False

if use_pythor3_defaults:
    # fbcorr
    from pythor3.operation import fbcorr_
    fbcorr_DEFAULT_STRIDE = fbcorr_.DEFAULT_STRIDE
    fbcorr_DEFAULT_MIN_OUT = fbcorr_.DEFAULT_MIN_OUT
    fbcorr_DEFAULT_MAX_OUT = fbcorr_.DEFAULT_MAX_OUT
    fbcorr_DEFAULT_MODE = fbcorr_.DEFAULT_MODE

    # lnorm
    from pythor3.operation import lnorm_
    lnorm_DEFAULT_INKER_SHAPE = lnorm_.DEFAULT_INKER_SHAPE
    lnorm_DEFAULT_OUTKER_SHAPE = lnorm_.DEFAULT_OUTKER_SHAPE
    lnorm_DEFAULT_REMOVE_MEAN = lnorm_.DEFAULT_REMOVE_MEAN
    lnorm_DEFAULT_DIV_METHOD = lnorm_.DEFAULT_DIV_METHOD
    lnorm_DEFAULT_THRESHOLD = lnorm_.DEFAULT_THRESHOLD
    lnorm_DEFAULT_STRETCH = lnorm_.DEFAULT_STRETCH
    lnorm_DEFAULT_MODE = lnorm_.DEFAULT_MODE
    lnorm_EPSILON = lnorm_.EPSILON

    from pythor3.model import SequentialLayeredModel
else:
    # fbcorr
    fbcorr_DEFAULT_STRIDE = 1
    fbcorr_DEFAULT_MIN_OUT = None
    fbcorr_DEFAULT_MAX_OUT = None
    fbcorr_DEFAULT_MODE = 'valid'

    # lnorm
    lnorm_DEFAULT_INKER_SHAPE = (3, 3)
    lnorm_DEFAULT_OUTKER_SHAPE = lnorm_DEFAULT_INKER_SHAPE
    lnorm_DEFAULT_REMOVE_MEAN = False
    lnorm_DEFAULT_DIV_METHOD = 'euclidean'
    lnorm_DEFAULT_THRESHOLD = 0.
    lnorm_DEFAULT_STRETCH = 1.
    lnorm_DEFAULT_MODE = 'valid'
    lnorm_EPSILON = 1e-4


def get_into_shape(x):
    if hasattr(x,'__iter__'):
        x = np.array(x)
        assert x.ndim == 1
        x = x[np.newaxis, :, np.newaxis, np.newaxis]
        x = x.astype(np.float32)
    return x


def dict_add(a, b):
    rval = dict(a)
    rval.update(b)
    return rval


def alloc_filterbank(n_filters, height, width, channels, dtype,
        method_name, method_kwargs, normalize=True, SLMP=None):
    """
    Generate the same weights as are generated by pythor3
    """
    if height != width:
        raise ValueError('filters must be square')
    if channels is None:
        filter_shape = [n_filters, height, width]
    else:
        filter_shape = [n_filters, height, width, channels]

    if method_name == 'random:uniform':
        rseed = method_kwargs.get('rseed', None)
        np.random.seed(rseed)
        fb_data = np.random.uniform(size=filter_shape)
    elif method_name == 'gabor2d:grid':
        # allocate a filterbank spanning a grid of frequencies, phases,
        # orientations
        raise NotImplementedError()

    else:
        raise ValueError(
            "method to generate filterbank '%s' not understood"
            % method_name)

    # normalize each filter in the bank if needed
    if normalize:
        # TODO: vectorize these computations, do all at once.
        for fidx, filt in enumerate(fb_data):
            # normalization here means zero-mean, unit-L2norm
            filt -= filt.mean()
            filt_norm = np.sqrt((filt * filt).sum())
            assert filt_norm != 0
            filt /= filt_norm
            fb_data[fidx] = filt

    return fb_data.astype(dtype)


class InvalidDescription(Exception):
    """Model description was invalid"""


def boxconv((x, x_shp), kershp, channels=False):
    """
    channels: sum over channels (T/F)
    """
    kershp = tuple(kershp)
    if channels:
        rshp = (   x_shp[0],
                    1,
                    x_shp[2] - kershp[0] + 1,
                    x_shp[3] - kershp[1] + 1)
        kerns = np.ones((1, x_shp[1]) + kershp, dtype=x.dtype)
    else:
        rshp = (   x_shp[0],
                    x_shp[1],
                    x_shp[2] - kershp[0] + 1,
                    x_shp[3] - kershp[1] + 1)
        kerns = np.ones((1, 1) + kershp, dtype=x.dtype)
        x_shp = (x_shp[0]*x_shp[1], 1, x_shp[2], x_shp[3])
        x = x.reshape(x_shp)
    try:
        rval = tensor.reshape(
                conv.conv2d(x,
                    kerns,
                    image_shape=x_shp,
                    filter_shape=kerns.shape,
                    border_mode='valid'),
                rshp)
    except Exception, e:
        if "Bad size for the output shape" in str(e):
            raise InvalidDescription()
        else:
            raise
    return rval, rshp


@pyll.scope.define_info(o_len=2)
def slm_fbcorr((x, x_shp), n_filters,
        ker_size,
        min_out=fbcorr_DEFAULT_MIN_OUT,
        max_out=fbcorr_DEFAULT_MAX_OUT,
        stride=fbcorr_DEFAULT_STRIDE,
        mode=fbcorr_DEFAULT_MODE,
        generate=None):
    assert x.dtype == 'float32'
    filter_shape = (ker_size, ker_size)
    # Reference implementation:
    # ../pythor3/pythor3/operation/fbcorr_/plugins/scipy_naive/scipy_naive.py
    if stride != fbcorr_DEFAULT_STRIDE:
        raise NotImplementedError('stride is not used in reference impl.')
    kerns = alloc_filterbank(n_filters=n_filters,
            height=filter_shape[0],
            width=filter_shape[1],
            channels=x_shp[1],
            dtype=x.dtype,
            method_name=generate[0],
            method_kwargs=generate[1])
    kerns = kerns.transpose(0, 3, 1, 2).copy()[:,:,::-1,::-1]
    x = conv.conv2d(
            x,
            kerns,
            image_shape=x_shp,
            filter_shape=kerns.shape,
            border_mode=mode)
    if mode == 'valid':
        x_shp = (x_shp[0], n_filters,
                x_shp[2] - filter_shape[0] + 1,
                x_shp[3] - filter_shape[1] + 1)
    elif mode == 'full':
        x_shp = (x_shp[0], n_filters,
                x_shp[2] + filter_shape[0] - 1,
                x_shp[3] + filter_shape[1] - 1)
    else:
        raise NotImplementedError('fbcorr mode', mode)

    if min_out is None and max_out is None:
        return x, x_shp
    elif min_out is None:
        return tensor.minimum(x, max_out), x_shp
    elif max_out is None:
        return tensor.maximum(x, min_out), x_shp
    else:
        return tensor.clip(x, min_out, max_out), x_shp


@pyll.scope.define_info(o_len=2)
def slm_lpool((x, x_shp),
        ker_size=3,
        order=1,
        stride=1,
        mode='valid'):
    assert x.dtype == 'float32'
    order=float(order)

    ker_shape = (ker_size, ker_size)
    if hasattr(order, '__iter__'):
        o1 = (order == 1).all()
        o2 = (order == order.astype(np.int)).all()
    else:
        o1 = order == 1
        o2 = (order == int(order))

    if o1:
        r, r_shp = boxconv((x, x_shp), ker_shape)
    elif o2:
        r, r_shp = boxconv((x ** order, x_shp), ker_shape)
        r = tensor.maximum(r, 0) ** (1.0 / order)
    else:
        r, r_shp = boxconv((abs(x) ** order, x_shp), ker_shape)
        r = tensor.maximum(r, 0) ** (1.0 / order)

    if stride > 1:
        r = r[:, :, ::stride, ::stride]
        # intdiv is tricky... so just use numpy
        r_shp = np.empty(r_shp)[:, :, ::stride, ::stride].shape
    return r, r_shp


@pyll.scope.define_info(o_len=2)
def slm_lnorm((x, x_shp),
        ker_size=lnorm_DEFAULT_INKER_SHAPE[0],
        remove_mean=lnorm_DEFAULT_REMOVE_MEAN,    # False
        div_method=lnorm_DEFAULT_DIV_METHOD,      # 'euclidean'
        threshold=lnorm_DEFAULT_THRESHOLD,        # 0.
        stretch=lnorm_DEFAULT_STRETCH,            # 1.
        mode=lnorm_DEFAULT_MODE,                  # 'valid'
        ):
    assert x.dtype == 'float32'
    inker_shape=(ker_size, ker_size)
    outker_shape=(ker_size, ker_size)  # (3, 3)
    # Reference implementation:
    # ../pythor3/pythor3/operation/lnorm_/plugins/scipy_naive/scipy_naive.py
    EPSILON = lnorm_EPSILON
    if mode != 'valid':
        raise NotImplementedError('lnorm requires mode=valid', mode)

    threshold = float(threshold)
    stretch = float(stretch)

    if outker_shape == inker_shape:
        size = np.asarray(x_shp[1] * inker_shape[0] * inker_shape[1],
                dtype=x.dtype)
        ssq, ssqshp = boxconv((x ** 2, x_shp), inker_shape,
                channels=True)
        xs = inker_shape[0] // 2
        ys = inker_shape[1] // 2
        # --local contrast normalization in regions that are not symmetric
        #   about the pixel being normalized feels weird, but we're
        #   allowing it here.
        xs_inc = (inker_shape[0] + 1) % 2
        ys_inc = (inker_shape[1] + 1) % 2
        if div_method == 'euclidean':
            if remove_mean:
                arr_sum, _shp = boxconv((x, x_shp), inker_shape,
                        channels=True)
                arr_num = (x[:, :, xs-xs_inc:-xs, ys-ys_inc:-ys]
                        - arr_sum / size)
                arr_div = EPSILON + tensor.sqrt(
                        tensor.maximum(0,
                            ssq - (arr_sum ** 2) / size))
            else:
                arr_num = x[:, :, xs-xs_inc:-xs, ys-ys_inc:-ys]
                arr_div = EPSILON + tensor.sqrt(ssq)
        else:
            raise NotImplementedError('div_method', div_method)
    else:
        raise NotImplementedError('outker_shape != inker_shape',outker_shape, inker_shape)
    if (hasattr(stretch, '__iter__') and (stretch != 1).any()) or stretch != 1:
        arr_num = arr_num * stretch
        arr_div = arr_div * stretch
    arr_div = tensor.switch(arr_div < (threshold + EPSILON), 1.0, arr_div)

    r = arr_num / arr_div
    r_shp = x_shp[0], x_shp[1], ssqshp[2], ssqshp[3]
    return r, r_shp

